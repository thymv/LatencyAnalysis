package com.thyvu.latency;


import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.text.DateFormat;
import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.Queue;
import java.util.Scanner;
import java.util.TimeZone;


import com.amazonaws.services.cloudwatch.AmazonCloudWatch;
import com.amazonaws.services.cloudwatch.AmazonCloudWatchClientBuilder;
import com.amazonaws.services.logs.AWSLogsClient;
import com.amazonaws.services.logs.AWSLogsClientBuilder;
import com.amazonaws.services.logs.model.FilterLogEventsRequest;
import com.amazonaws.services.logs.model.FilterLogEventsResult;



public class LatencyAnalysis {
	final static String LOCAL_TIMEZONE_ID = "America/Los_Angeles";
	final static String CLOUDWATCH_LAMBDA_GROUP_NAME = "/aws/lambda/myFirstLambda";
	final static String CLOUDWATCH_IOT_GROUP_NAME = "AWSIotLogs";
	
	final static AmazonCloudWatch cw = AmazonCloudWatchClientBuilder.defaultClient();
	
	public static void main(String[] args) {
		Queue<Trial> trials = new LinkedList<Trial>();
		Queue<Trial> processedTrials = new LinkedList<Trial>();
		
		// create 2 new files, one to to store raw CloudWatch Logs related to lambda, 
		// and one for raw CloudWatch Logs related to IoT
		File lambdaLogFile = new File("rawLambdaLogs");
		File iotLogFile = new File("rawIotLogs");
		try {
			FileWriter fw = new FileWriter(lambdaLogFile, false);
			FileWriter fw2 = new FileWriter(iotLogFile, false);
		} catch (IOException e) {
			e.printStackTrace();
		}
		
		System.out.println("This program takes a log file generated by MySensor.java and \n"+
				"retrieve AWS CloudWatch timestamps to calculate latencies in milliseconds." );

		Scanner scanner = new Scanner(System.in);
		System.out.println("Type absolute path of messageToSensor log file:");
		String logFilePath = scanner.nextLine().trim();
		
		File file = new File(logFilePath);
		
		if(!file.exists()){
			System.out.println("File doesn't exist.");
		}else{
			processLogFile(trials, file);
			System.out.println("\nLog file contains " + trials.size() +" trials.");
			System.out.println("\n\n ::::::Timestamps and latencies for each trial::::::\n\n");
			
			while (!trials.isEmpty()){
				Trial trial = trials.remove();
				processIotLogs(trial, CLOUDWATCH_IOT_GROUP_NAME, iotLogFile);
				processLambdaLogs(trial, CLOUDWATCH_LAMBDA_GROUP_NAME, lambdaLogFile);
				System.out.println("Trial with source time at " + parseEpochToUTCDate(trial.srcTime) + " (US Pacific Time)" );
				trial.printTimestamps();
				trial.printLatencies();
				System.out.println("\n------------------------------------------------------------------------\n");
				processedTrials.add(trial);
			}
		}
		
		if (!processedTrials.isEmpty()){
			Trial avgTrial = getAverageLatencies(processedTrials);
			System.out.println("::::::AVERAGE OF ALL TRIALS::::::");
			avgTrial.printLatencies();
		}
		
		
		System.out.println("\n\nOptional: Check the following files for raw CloudWatch Logs retrieved from AWS:");
		System.out.println(lambdaLogFile.getAbsolutePath());
		System.out.println(iotLogFile.getAbsolutePath());
	}

	
	
	/*
	 * Populate trial queue with trial data from file
	 * @param:
	 * Queue<Trial> trialQueue		queue to store trials with basic data
	 * File file					log file generated by MySensor.java
	 * */
	public static void processLogFile(Queue<Trial> trialQueue, File file){
		System.out.println("Trial information:");
		BufferedReader in;
		String line;
		try {
			in = new BufferedReader(new FileReader(file));
			while ((line = in.readLine()) != null) {
				System.out.println(line);
		        String[] tokens = line.split(" ");
		      
		        Trial trial = new Trial();
		        for(int i = 0; i < tokens.length-1; i=i+2){
		           String timeName = tokens[i];
		           if(timeName.equals("receivedTime")){
		        	   trial.receivedTime = Long.parseLong(tokens[i+1]);
		           }else if(timeName.equals("srcTime")){
		        	   trial.srcTime = Long.parseLong(tokens[i+1]);
		           }else if(timeName.equals("iotTime")){
		        	   trial.iotTime = Long.parseLong(tokens[i+1]);
		           }   	   
		        }
		        trialQueue.add(trial);
		    }
		    in.close();
		} catch (FileNotFoundException e) {
			e.printStackTrace();
		} catch (IOException e) {
			e.printStackTrace();
		}	
	}
	
	
	
	
	/*
	 * Parse AWS CloudWatch Logs for Lambda services
	 * @param:
	 * Trial trial		Trial to store relevant timestamps
	 * String groupName	Lambda function's group name in CloudWatch service
	 * */
	public static void processLambdaLogs(Trial trial, String groupName, File lambdaLogFile){
		long timestamp = 0L;
		
		// Create CloudWatch Log request
		FilterLogEventsRequest request = new FilterLogEventsRequest();
		request.setStartTime(trial.iotTime - 3000);
		request.setEndTime(trial.receivedTime + trial.getAbsoluteOffset());
		request.setLogGroupName(groupName);
		request.setFilterPattern("");
		
		// Get CloudWatch Log results
		AWSLogsClient logClient = (AWSLogsClient) AWSLogsClientBuilder.defaultClient();
	    FilterLogEventsResult results = logClient.filterLogEvents(request);
	    
	    // print to lambdaLogFile
	    BufferedWriter out;
	    try {
			out = new BufferedWriter(new FileWriter(lambdaLogFile.getName(), true));
			out.write(results.toString() + " \n\n\n");
	        out.close();
		} catch (IOException e1) {
			// TODO Auto-generated catch block
			e1.printStackTrace();
		}
	    
	    // get timestamps for this trial
	    String[] logLines = results.toString().split("LogStreamName");
	    for(String logLine : logLines){
	    	if(logLine.contains("Timestamp")){
	    		timestamp = Long.parseLong(logLine.substring(logLine.indexOf("Timestamp:")+11, logLine.indexOf(",Message")));
	    		if (logLine.contains("Loading function")){
	    			trial.lambdaStartTime = timestamp;
	    		}else if(logLine.contains("START") && trial.lambdaStartTime == 0L){
	    			trial.lambdaStartTime = timestamp;
	    		}else if (logLine.contains("publishing to sns")){
	    			trial.lambdaSendToSnsTime = timestamp;
	    		}else if (logLine.contains("published to sns")){
	    			trial.lambdaSendToSnsSuccessTime = timestamp;
	    		}else if (logLine.contains("publishing to iot")){
	    			trial.lambdaSendToIotTime = timestamp;
	    		}else if (logLine.contains("published to iot")){
	    			trial.lambdaSendToIotSuccessTime = timestamp;
	    		}else if(logLine.contains("END")){
	    			trial.lambdaEndTime = timestamp;
	    			long cwlTime = Long.parseLong(logLine.substring(logLine.indexOf("IngestionTime:")+15, logLine.indexOf(",EventId")));
	    			trial.cloudWatchLogFromLambdaTime = cwlTime;
	    			break; // end of relevant log, no need to continue loop
	    		}
	    	}
	    }
		
	}
	
	/*
	 * Parse AWS CloudWatch Logs for IoT services
	 * @param:
	 * Trial trial		Trial to store relevant timestamps
	 * String groupName	IoT service's group name in CloudWatch service
	 * */
	public static void processIotLogs(Trial trial, String groupName, File iotLogFile){
		long timestamp=0L;
		
		// Create CloudWatch Log request
		FilterLogEventsRequest request = new FilterLogEventsRequest();
		request.setStartTime(trial.iotTime - 3000);
		request.setEndTime(trial.receivedTime + trial.getAbsoluteOffset());
		request.setLogGroupName(groupName);
		request.setFilterPattern("");
		
		// Get CloudWatch Logs
		AWSLogsClient logClient = (AWSLogsClient) AWSLogsClientBuilder.defaultClient();
	    FilterLogEventsResult results = logClient.filterLogEvents(request);
	    
	    // print to lambdaLogFile
	    BufferedWriter out;
	    try {
			out = new BufferedWriter(new FileWriter(iotLogFile.getName(), true));
			out.write(results.toString() + " \n\n\n");
	        out.close();
		} catch (IOException e1) {
			// TODO Auto-generated catch block
			e1.printStackTrace();
		}
	    
	    // Get timestamps for this trial
	    String[] logLines = results.toString().split("LogStreamName");
	    for(String logLine : logLines){
	    	if(logLine.contains("Timestamp")){
	    		timestamp = Long.parseLong(logLine.substring(logLine.indexOf("Timestamp:")+11, logLine.indexOf(",Message")));
	    		if (logLine.contains("MQTT Client Connect")){ //and "SUCCESS"
	    			trial.iotConnectTime = timestamp;
	    		}else if (logLine.contains("PublishEvent TOPICNAME:sensorTopic")){
	    			trial.iotTopicFromSensorTime = timestamp;
	    		}else if(logLine.contains("MatchingRuleFound")){
	    			trial.iotRuleFoundTime = timestamp;
	    		}else if (logLine.contains("DynamoActionSuccess")){
	    			trial.dynamoActionSuccessTime = timestamp;
	    		}else if (logLine.contains("PublishOut TOPICNAME:messageToSensor")){
	    			trial.iotTopicFromLambdaTime = timestamp;
	    			long cwlTime = Long.parseLong(logLine.substring(logLine.indexOf("IngestionTime:")+15, logLine.indexOf(",EventId")));
	    			trial.cloudWatchLogFromIotTime = cwlTime;
	    			break; // end of relevant log, no need to continue loop

	    		}
	    	}
	    }
		
	}
	
	
	
	/* Return: Trial object with average latencies values
	 * @Param:
	 * Queue<Trial> processedTrials		queue of Trials containing timestamps and latencies
	 * */
	public static Trial getAverageLatencies(Queue<Trial> processedTrials){
		Trial avgTrial = new Trial();
		int numOfTrials = processedTrials.size();
		Iterator<Trial> it = processedTrials.iterator();
		while(it.hasNext()){
			Trial currTrial = it.next();
			avgTrial.rtt += currTrial.rtt;
			avgTrial.iotTopicFromSensor2IotTopicFromLambda += currTrial.iotTopicFromSensor2IotTopicFromLambda;
			avgTrial.roundTripNetwork += currTrial.roundTripNetwork;
			avgTrial.iotTopic2Rule += currTrial.iotTopic2Rule;
			avgTrial.rule2db += currTrial.rule2db;
			avgTrial.db2lambda += currTrial.db2lambda;
			avgTrial.lambda2iotTopic += currTrial.lambda2iotTopic;
			avgTrial.lambda2sns += currTrial.lambda2sns;
			avgTrial.lambda2cw += currTrial.lambda2cw;
			avgTrial.iot2cw += currTrial.iot2cw;
		}
		
		avgTrial.rtt = avgTrial.rtt / numOfTrials;
		avgTrial.iotTopicFromSensor2IotTopicFromLambda = avgTrial.iotTopicFromSensor2IotTopicFromLambda/ numOfTrials;
		avgTrial.roundTripNetwork = avgTrial.roundTripNetwork / numOfTrials;
		avgTrial.iotTopic2Rule = avgTrial.iotTopic2Rule / numOfTrials;
		avgTrial.rule2db = avgTrial.rule2db / numOfTrials;
		avgTrial.db2lambda = avgTrial.db2lambda / numOfTrials;
		avgTrial.lambda2iotTopic = avgTrial.lambda2iotTopic / numOfTrials;
		avgTrial.lambda2sns = avgTrial.lambda2sns / numOfTrials;
		avgTrial.lambda2cw = avgTrial.lambda2cw / numOfTrials;
		avgTrial.iot2cw = avgTrial.iot2cw / numOfTrials;
		avgTrial.calculatedLatencies = true;
		
		return avgTrial;
		
	}
	
	/*
	 * @param
	 * long millisec	milliseconds since epoch
	 * Return equivalent "yyyy-MM-dd HH:mm:ss.SSS" formatted String
	 * */
	public static String parseEpochToUTCDate(long millisec){
		Date date = new Date(millisec);
		DateFormat format = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss.SSS");
		format.setTimeZone(TimeZone.getTimeZone(LOCAL_TIMEZONE_ID));
		return format.format(date);
		
	}
}
